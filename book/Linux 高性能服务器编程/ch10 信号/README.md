# 第10章 信号

## 10.1 Linux 信号概述

### 10.1.1 发送信号

1. Linux 下，一个进程给其他进程发送信号的 API 是 kill 函数

   ```c
   #include <sys/types.h>
   #include <signal.h>

   // pid: 目标进程
   //      pid > 0:   信号发送给 PID 为 pid 的进程
   //      pid = 0:   信号发送给本进程组内的其他进程
   //      pid = -1:  信号发送给除 init 进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限
   //      pid < -1:  信号发送给组 ID 为 -pid 的进程组中的所有成员
   // sig: 如果 sig 取值为 0，则 kill 函数不发送任何信号
   int kill(pid_t pid, int sig);

   // 函数成功时返回 0，失败则返回 -1 并设置 errno
   // errno:  EINVAL: 无效的信号
   //         EPERM: 该进程没有权限发送信号给任何一个目标进程
   //         ESRCH: 目标进程或进程组不存在
   ```

### 10.1.2 信号处理方式

1. 目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的原型如下：

   ```c
   #include <signal.h>

   // 信号处理函数只带有一个整型参数，该参数用来指示信号类型
   // 信号处理函数应该是可重入的，否则很容易引发一些竞态条件。所以在信号处理函数中严禁调用一些不安全的函数
   typedef void (*__sighandler_t) (int);
   ```

2. 除了用户自定义信号处理函数外，bits/signum.h 头文件中还定义了信号的两种其他处理方式 SIG_IGN 和 SIG_DEL

   ```c
   #include <bits/signum.h>
   // 使用信号的默认处理方式
   #define SIG_DFL ((__sighandler_t) 0)
   // 忽略目标信号
   #define SIG_IGN ((__sighandler_t) 1)

   // 信号的默认处理方式有如下几种：
   //    结束进程 Term
   //    忽略信号 Ign
   //    结束进程并生成核心转储文件 Core
   //    暂停进程 Stop
   //    继续进程 Cont
   ```

### 10.1.4 中断系统调用

如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为信号设置了信号处理函数，则默认情况下系统调用将被中断，并且 errno 被设置为 EINTR。我们可以使用 sigaction 函数为信号设置 SA_RESTART 标志以自动重启被该信号中断的系统调用

对于默认行为是暂停进程的信号（比如 SIGSTOP、SIGTTIN），如果我们没有为它们设置信号处理函数，则它们也可以中断某些系统调用

## 10.2 信号函数

### 10.2.1 signal 系统调用

### 10.2.2 sigaction 系统调用

## 10.3 信号集

### 10.3.3 被挂起的信号

1. 设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，则操作系统将信号设置为进程的一个被挂起的信号。如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到。

   ```c
   #include <signal.h>

   // 获取进程当前被挂起的信号集
   // set: 用于保存被挂起的信号集
   int sigpending(sigset_t* set);

   // 成功返回 0，失败返回 -1 并设置 errno
   ```

## 10.4 统一事件源

信号是一种异步事件

## 10.5 网络编程相关信号

### 10.5.2 SIGPIPE

1. 默认情况下，往一个读端关闭的管道或读端关闭的 socket 连接中写数据将引发 SIGPIPE 信号。

### 10.5.3 SIGURG

1. 在 Linux 环境下，内核通知