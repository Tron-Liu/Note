# 第8章 高性能服务器程序框架

## 8.1 服务器模型

### 8.1.1 C/S 模型

## 8.3 I/O 模型

1. Linux 上常用的 I/O 复用函数是 select、poll、epoll_wait。需要指出的是，I/O 复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个 I/O 事件的能力
2. 从理论上来说，阻塞 I/O、I/O 复用、信号驱动 I/O 都是同步 I/O 模型。因为在这三种 I/O 模型中，I/O 的读写操作，都是在 I/O 事件发生之后，由应用程序来完成的。对异步 I/O 而言，用户可以直接对 I/O 执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及 I/O 操作完成之后
3. I/O 模型对比

   | I/O 模型 | 读写操作和阻塞阶段 |
   |:--------|:----------------|
   | 阻塞 I/O | 程序阻塞于读写函数 |
   | I/O 复用 | 程序阻塞于 I/O 复用系统调用，但可同时监听多个 I/O 事件。对 I/O 本身的读写操作是非阻塞的 |
   | SIGIO 信号 | 信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段 |
   | 异步 I/O | 内核执行读写操作并触发读写完成事件。程序没有阻塞阶段 |

## 8.4 两种高效的事件处理模式

### 8.4.1 Reactor 模式

1. Reactor 模式要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑处理单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
2. 使用同步 I/O 模型实现的 Reactor 模式的工作流程是，以 epoll_wait 为例：
   * 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
   * 主线程调用 epoll_wait 等待 socket 上有数据可读
   * 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列
   * 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果

### 8.4.2 Proactor 模式

1. 与 Reactor 模式不同，Proactor 模式将 所有 I/O 操作都交给主线程和内核来处理，工作线程仅负责业务逻辑
2. 使用异步 I/O 模型实现的 Proactor 模式的工作流程（以 aio_read 和 aio_write 为例）：
   * 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
   * 主线程继续处理其他逻辑
   * 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
   * 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序
   * 主线程继续处理其他逻辑
   * 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
   * 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket

### 8.4.3 模拟 Proactor 模式

1. 使用同步 I/O 模拟（以 epoll_wait）为例模拟出 Proactor 模式：
   * 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件
   * 主线程调用 epoll_wait 等待 socket 上有数据可读
   * 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列
   * 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件
   * 主线程调用 epoll_wait 等待 socket 可写
   * 当 socker 可写时，epoll_wait 通知主线程。主线程网 socket 上写入服务器处理客户请求的结果

## 8.5 两种高效的并发模式

1. 并发编程的目的是让程序“同事”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换而使效率降低
2. 并发模式是指 I/O 处理单元和多个逻辑单元之间协调完成任务的方法

### 8.5.1 半同步/半异步模式

1. 在 I/O 模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种 I/O 事件（是就绪事件还是完成事件），以及该由谁来完成 I/O 读写（是应用程序还是内核）。
2. 在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等
3. 半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理 I/O 事件，异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象

### 8.5.2 领导者和追随者模式

## 8.7 提高服务器性能地其他建议

### 8.7.3 上下文切换和锁

1. 锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就应该避免使用锁。
2. 如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。
