# 第九章 Windows下的动态链接

## 9.1 DLL简介

1. DLL即 **动态链接库 (Dynamic-Link Library)** 的缩写，它相当于Linux下的共享对象。
2. DLL的设计目的与共享对象有些出入，DLL更加强调模块化，即微软希望通过DLL机制加强软件的模块设计，使得各种模块之间能够松散地组合、重用和升级。

### 9.1.1 进程地址空间和内存管理

### 9.1.2 基地址和RVA

1. 基地址 (Base Address): 当一个PE文件被装载时，其进程地址空间中的起始地址就是基地址。对于任何一个PE文件来说，它都有一个优先装载的基地址，这个值就是PE文件头中的Image Base。对于一个可执行EXE文件来说，Image Base一般值是0x400000，对于DLL文件来说，这个值一般是0x10000000。
2. 相对地址 (RVA, Relative Virtual Address): 相对地址就是一个地址相对于基地址的偏移，比如一个PE文件被装载到0x10000000，即基地址为0x10000000，那么RVA为0x1000的地址为0x10001000。
3. Windows 在装载 DLL 时，会先尝试把它装载到由Image Base指定的虚拟地址；若该地址区域已被其他模块占用，那 PE 装载器会选用其他空闲地址。

### 9.1.3 DLL共享数据段

### 9.1.4 DLL的简单例子

1. 我们通过简单的例子来了解最简单的 DLL 的创建和使用，最基本的概念时 **导出（Export）** 的概念。在 ELF 中，共享库中的所有全局函数和变量在默认情况下都可以被其他模块使用，也就是说 ELF 默认导出所有的全局符号。但是在 DLL 中情况有所不同，我们需要显式地“告诉”编译器我们需要导出某个符号，否则编译器默认所有符号都不导出。
2. 当我们在程序中使用 DLL 导出地符号时，这个过程被称为 **导入（import）**

### 9.1.5 创建 DLL

### 9.1.6 使用 DLL

### 9.1.7 使用模块定义文件

### 9.1.8 DLL 显式运行时链接

1. 与 ELF 类似

## 9.2 符号导出导入表

### 9.2.1 导出表

### 9.2.4 导入表

1. 如果我们在某个程序中使用到了来自 DLL 的函数或者变量，那么我们就把这种行为叫做 **符号导入(Symbol Importing)**

## 9.3 DLL 优化

### 9.3.1 重定基地址 (Rebasing)

### 9.3.2 序号

1. 一个 DLL 中每一个导出的函数都有一个对应的序号 (Ordinal Number)。一个导出函数甚至可以没有函数名，但它必须有一个唯一的序号。

### 9.3.3 导入函数绑定

## 9.4 C++ 与动态链接

## 9.5 DLL HELL
