# 第十章 内存

## 10.1 程序的内存布局

> 一般来讲，应用程序使用的内存空间里有如下 "默认" 的区域：
>
> + 栈：栈用于维护函数调用的上下文。离开了栈，函数调用就没法实现。栈通常在用户空间的最高地址处分配，通常有数兆字节的大小。
>
> + 堆：堆是用来容纳应用程序动态分配的内存区域，当程序使用 malloc 或 new 分配内存时，得到的内存来自堆里。堆通常存在于栈的下方（低地址方向）。在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多，可以有几十至数百兆字节的容量。
>
> + 可执行文件映像：这里存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。
>
> + 动态链接库映射区：这个区域用于映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其他共享库，那么系统就会为 **可执行文件** 在从 0x40000000 开始的地址分配相应的空间，并将 **依赖的共享库** 载入到该空间
>
> + 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称。例如，大多数操作系统里，极小的地址通常都是不允许访问的，如 NULL。通常 C 语言将无效指针赋值为 0 也是出于这个考虑，因为 0 地址上正常情况下不可能有有效的可访问数据。

### Q&A

> Q  
> 我写的程序常常出现 "段错误（segment fault）" 或者 " 非法操作，该内存地址不能 read/write" 的错误信息，这是怎么回事？
>
> A  
> 这是典型的非法指针解引用造成的错误。当指针指向一个不允许读或写的内存地址，而程序却试图利用指针来读或写该地址的时候，就会出现这个错误。在 Linux 或 Windows 的内存布局中，有些地址是始终不能读写的，例如 0 地址。还有些地址一开始不允许读写，应用程序必须事先请求获取这些地址的读写权，或者某些地址一开始并没有映射到实际的物理内存，应用程序必须事先请求将这些地址映射到实际的物理地址（commit），之后才能够自由地读写这片内存。当一个指针指向这些区域的时候，对它指向的内存进行读写就会引发错误。造成这样的最普遍原因有两种：
>
>> 1. 程序员将指针初始化为 NULL，之后却没有给它一个合理的值就开始使用指针。
>>
>> 2. 程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用指针。

## 10.2 栈与调用惯例

### 10.2.1 什么是栈

1. **栈（stack）** 先入后出（First In Last Out，FIFO）的一种容器。在经典的操作系统里，栈总是向下增长的。在 i386 下，栈顶由称为 **esp** 的寄存器进行定位。压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大。

2. 栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录（Activate Record）。堆栈帧一般包括如下几方面内容：

    > + 函数的返回地址和参数
    > + 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他的临时变量。
    > + 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

3. 在 i386 中

## 10.3 堆与内存管理

## 10.4 本章小结
