# 第七章 动态链接

## 7.3 地址无关代码

## 7.6 动态链接的步骤和实现

### 7.6.1 动态链接器自举

1. 动态链接器本身不可以依赖于其他任何共享对象；其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成  
2. 动态链接器入口地址即是自举代码的入口，当操作系统将进程

### 7.6.2 装载共享对象

#### 符号的优先级

1. 一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称为共享对象 **全局符号接入（Global Symbol Interpose）**  
2. 关于全局符号介入这个问题，实际上Linux下的动态链接器是这样处理的：它定义了一个规则，那就是当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略
3. 由于存在这种重名符被直接忽略的问题，当程序使用大量共享对象时应该时应该非常小心符号的重名问题，如果两个符号重名又执行不同的功能，那么程序

#### 全局符号介入与地址无关代码

### 7.6.3 重定位和初始化

## 7.7 显式运行时链接

1. 支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做 **显式运行时链接 (Explicit Run-time Linking)**，有时候也叫做 **运行时加载**。也就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。
2. 一般的共享对象不需要进行任何修改就可以进行运行时装载，这种共享对象往往被叫做 **动态装载库(Dynamic Loading Library)** ，其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。

### 7.7.1 dlopen()

1. `dopen()` 函数用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程

### 7.7.2 dlsym()

1. `dlsym` 函数基本上是运行时装载的核心部分，我们可以通过这个函数找到所需要的符号。它的定义如下：

```c
void * dlsym(void *handle, char *symbol);
```

#### 符号优先级

### 7.7.3 dlerror()

### 7.7.4 dlclose()
